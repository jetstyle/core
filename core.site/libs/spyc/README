Spyc 3.0 (svn rev 12) + patch
http://spyc.sourceforge.net


Index: spyc.yaml
===================================================================
--- spyc.yaml	(revision 12)
+++ spyc.yaml	(working copy)
@@ -49,7 +49,7 @@
 no time: >
   There isn't any time
   for your tricks!
-
+  
   Do you understand?
 
 # A literal block as a mapped value
@@ -113,4 +113,101 @@
   javascripts:     [dom1.js, dom.js]
 
 # Added in .2
-1040: Ooo, a numeric key! # And working comments? Wow! Colons in comments: a menace (0.3).
\ No newline at end of file
+1040: Ooo, a numeric key! # And working comments? Wow! Colons in comments: a menace (0.3).
+
+map with colons:
+  one : 'foo bar: bar baz'
+  two : { foo bar: bar baz }
+    three : foo bar: bar baz
+  date: 20070101 22:59:24
+  four: foo - {bar}
+
+list of maps:
+  - name : chris
+    age  : young
+    brand: lucky strike
+  - compiled languages: *CLANGS
+    all languages list: [*CLANGS, *DLANGS]
+    all languages map : {compiled: *CLANGS, interpreted: *DLANGS}
+
+
+more compiled languages:
+  - Haskell
+  <<: *CLANGS
+
+full languages list:
+  <<: [Haskell, E]
+  <<: *DLANGS
+  <<: *CLANGS
+
+stupid map:
+  i: am
+  <<: {another: example, of: the}
+  key: merging
+
+stupid map:
+  i: am
+  <<: {another: example, of: the}
+  key: merging
+
+empty lines:
+  # comment
+  # commetn
+  - PHP Class
+  
+  - Basic YAML Loader
+
+  - Very Basic YAML Dumper # comment
+
+empty inlines:
+  list:
+    - {}
+    - []
+  empty string:
+  map:
+    list: []
+    map: {}
+
+strip: |-
+  text
+clip: |
+  text
+keep: |+
+  text
+
+- |
+ detected
+- >+
+
+  
+  # detected
+- |1
+  explicit
+- >
+ 	
+ detected
+strip: |-
+  text
+clip: |
+  text
+keep: |+
+  text
+foor:
+  strip empty: >-
+
+  clip empty: >
+ 
+  keep empty: >+
+ 
+strip empty: >-
+ 
+keep empty: >+
+
+clip empty: >
+ 
+quoted keys: 
+  "": foo
+  "bar": "string"
+  "1": "one"
+  2: "two"
+
Index: spyc.php
===================================================================
--- spyc.php	(revision 12)
+++ spyc.php	(working copy)
@@ -42,9 +42,9 @@
   var $_containsGroupAlias = false;
   var $path;
   var $result;
-  var $LiteralBlockMarkers = array ('>', '|');
-  var $LiteralPlaceHolder = '___YAML_Literal_Block___';
   var $SavedGroups = array();
+  var $emptyValue = ""; /* Just set to NULL for http://yaml.org/type/null.html */
+  var $eol = NULL;      /* End Of Line will be autodetected */
 
   /**#@+
   * @access public
@@ -267,31 +267,28 @@
     $this->path = array();
     $this->result = array();
 
+    // detect End Of line
+    if (!isset($this->eol)) {
+      if    (substr($Source[0], -2, 2) === "\r\n") $this->eol = "\r\n";
+      else  $this->eol = substr($Source[0], -1, 1);
+    }
 
-    for ($i = 0; $i < count($Source); $i++) {
-      $line = $Source[$i];
-      $lineIndent = $this->_getIndent($line);
-      $this->path = $this->getParentPathByIndent($lineIndent);
+    // let's go
+    $this->Source = $Source;
+    $this->line   = -1;
+
+    while (false !== ($line = $this->nextLine())) {
+      $this->lineIndent = $lineIndent = $this->_getIndent($line);
       $line = $this->stripIndent($line, $lineIndent);
+
       if ($this->isComment($line)) continue;
 
-      if ($literalBlockStyle = $this->startsLiteralBlock($line)) {
-        $line = rtrim ($line, $literalBlockStyle . "\n");
-        $literalBlock = '';
-        $line .= $this->LiteralPlaceHolder;
+      $this->path = $this->getParentPathByIndent($lineIndent);
+      $lineArray = $this->_parseLine($line); // can eat more than one line
 
-        while (++$i < count($Source) && $this->literalBlockContinues($Source[$i], $lineIndent)) {
-          $literalBlock = $this->addLiteralLine($literalBlock, $Source[$i], $literalBlockStyle);
-        }
-        $i--;
-      }
-      $lineArray = $this->_parseLine($line);
-      
-      if ($literalBlockStyle)
-      $lineArray = $this->revertLiteralPlaceHolder ($lineArray, $literalBlock);
-
       $this->addArray($lineArray, $lineIndent);
     }
+
     return $this->result;
   }
 
@@ -306,6 +303,11 @@
     return $foo;
   }
 
+  function nextLine ()
+  {
+    return ($this->line + 1 < count($this->Source)) ? $this->Source[++$this->line]: false;
+  }
+
   /**
      * Finds and returns the indentation of a YAML line
      * @access private
@@ -330,14 +332,11 @@
     if (!$line) return array();
     $array = array();
 
-    if ($group = $this->nodeContainsGroup($line)) {
+    if ($group = $this->nodeContainsGroupAnchor($line)) {
       $this->addGroup($line, $group);
       $line = $this->stripGroup ($line, $group);
     }
 
-    if ($this->startsMappedSequence($line))
-      return $this->returnMappedSequence($line);
-
     if ($this->startsMappedValue($line))
       return $this->returnMappedValue($line);
 
@@ -354,67 +353,111 @@
 
 
   /**
+     * Finds the type of the passed key, returns the key as the new type.
+     * @access private
+     * @param string $value
+     * @return mixed
+     */
+  function _toTypeKey($value) {
+
+    if (strpos($value, '#') !== false)
+      $value = trim(preg_replace('/#(.+)$/','',$value));
+
+    if (preg_match('/^("(.*)"|\'(.*)\')$/',$value,$matches)) {
+      $value = (string)preg_replace('/(\'\'|\\\\\')/',"'",end($matches));
+      $value = preg_replace('/\\\\"/','"',$value);
+    } elseif (strtolower($value) == 'null' or $value == '~') {
+      $value = null;
+    } elseif (preg_match ('/^[0-9]+$/', $value)) {
+      $value = (int)$value;
+    } elseif (is_numeric($value)) {
+      $value = (float)$value;
+    } else {
+      // Just a normal string, right?
+
+    }
+
+
+    //  print_r ($value);
+    return $value;
+  }
+
+  /**
      * Finds the type of the passed value, returns the value as the new type.
      * @access private
      * @param string $value
      * @return mixed
      */
-  function _toType($value) {
+  function _toType($value, $inline=false) {
 
+    $symbolsForReference = 'A-z0-9_\-';
+
     if (strpos($value, '#') !== false)
       $value = trim(preg_replace('/#(.+)$/','',$value));
 
-    if (preg_match('/^("(.*)"|\'(.*)\')/',$value,$matches)) {
+    if (preg_match('/^("(.*)"|\'(.*)\')$/',$value,$matches)) {
       $value = (string)preg_replace('/(\'\'|\\\\\')/',"'",end($matches));
       $value = preg_replace('/\\\\"/','"',$value);
-    } elseif (preg_match('/^\\[(.+)\\]$/',$value,$matches)) {
+    } elseif (preg_match('/^\\[(.*)\\]$/',$value,$matches)) {
       // Inline Sequence
-
+      $thing = trim($matches[1]);
+      // Propagate value array
+      $value  = array();
       // Take out strings sequences and mappings
-      $explode = $this->_inlineEscape($matches[1]);
+      if ($thing !== '') {
+        $explode = $this->_inlineEscape($thing);
 
-      // Propagate value array
-      $value  = array();
-      foreach ($explode as $v) {
-        $value[] = $this->_toType($v);
+        foreach ($explode as $v) {
+          $value[] = $this->_toType($v);
+        }
       }
-    } elseif (strpos($value,': ')!==false && !preg_match('/^{(.+)/',$value)) {
+    } elseif (preg_match('/^\*(['.$symbolsForReference.']+)/', $value, $matches)) {
+      // It's a alias
+      do {
+        $groupAlias = $matches[1];
+        if (!isset($this->SavedGroups[$groupAlias])) { echo "Bad group name: $groupAlias."; break; }
+        $groupPath = $this->SavedGroups[$groupAlias];
+        eval ('$value = $this->result' . Spyc::flatten ($groupPath) . ';');
+      } while (false);
+    } elseif (!$inline && substr($value, 0, 1) !== '{' && ($_p = strpos($value,': '))!==false) {
       // It's a map
-      $array = explode(': ',$value);
-      $key   = trim($array[0]);
-      array_shift($array);
-      $value = trim(implode(': ',$array));
-      $value = $this->_toType($value);
+      $key   = trim(substr($value, 0, $_p));
+      $key   = $this->_toTypeKey($key);
+      $value = trim(substr($value, $_p+2 )); unset($_p);
+      $value = $this->_toType($value, true);
       $value = array($key => $value);
-    } elseif (preg_match("/{(.+)}$/",$value,$matches)) {
+    } elseif (preg_match("/^{(.*)}$/",$value,$matches)) {
       // Inline Mapping
+      $thing = trim($matches[1]);
+      // Propogate value array
+      $value = array();
+      if ($thing !== '') {
+        // Take out strings sequences and mappings
+        $explode = $this->_inlineEscape($thing);
 
-      // Take out strings sequences and mappings
-      $explode = $this->_inlineEscape($matches[1]);
-
-      // Propogate value array
-      $array = array();
-      foreach ($explode as $v) {
-        $SubArr = $this->_toType($v);
-        if (empty($SubArr)) continue;
-        if (is_array ($SubArr)) {
-          $array[key($SubArr)] = $SubArr[key($SubArr)]; continue;
+        foreach ($explode as $v) {
+          $SubArr = $this->_toType($v);
+          if (empty($SubArr)) continue;
+          if (is_array ($SubArr)) {
+            $value[key($SubArr)] = $SubArr[key($SubArr)]; continue;
+          }
+          $value[] = $SubArr;
         }
-        $array[] = $SubArr;
       }
-      $value = $array;
-    } elseif (strtolower($value) == 'null' or $value == '' or $value == '~') {
+    } elseif (strtolower($value) == 'null' or $value == '~') {
       $value = null;
+    } elseif ($value == '') {
+      $value = $this->emptyValue;
     } elseif (preg_match ('/^[0-9]+$/', $value)) {
       $value = (int)$value;
-    } elseif (in_array(strtolower($value),
-    array('true', 'on', '+', 'yes', 'y'))) {
+    } elseif (in_array(strtolower($value), array('true', 'on', '+', 'yes', 'y'))) {
       $value = true;
-    } elseif (in_array(strtolower($value),
-    array('false', 'off', '-', 'no', 'n'))) {
+    } elseif (in_array(strtolower($value), array('false', 'off', '-', 'no', 'n'))) {
       $value = false;
     } elseif (is_numeric($value)) {
       $value = (float)$value;
+    } elseif ($sbinfo = $this->startsBlockScalar($value)) {
+      $value = $this->returnBlockScalar($value, $sbinfo);
     } else {
       // Just a normal string, right?
 
@@ -447,14 +490,14 @@
     unset($regex);
 
     // Check for sequences
-    if (preg_match_all('/\[(.+)\]/U',$inline,$seqs)) {
-      $inline = preg_replace('/\[(.+)\]/U','YAMLSeq',$inline);
+    if (preg_match_all('/\\[(.*)\\]/U',$inline,$seqs)) {
+      $inline = preg_replace('/\\[(.*)\\]/U','YAMLSeq',$inline);
       $seqs   = $seqs[0];
     }
 
     // Check for mappings
-    if (preg_match_all('/{(.+)}/U',$inline,$maps)) {
-      $inline = preg_replace('/{(.+)}/U','YAMLMap',$inline);
+    if (preg_match_all('/{(.*)}/U',$inline,$maps)) {
+      $inline = preg_replace('/{(.*)}/U','YAMLMap',$inline);
       $maps   = $maps[0];
     }
 
@@ -499,61 +542,48 @@
     return $explode;
   }
 
-  function literalBlockContinues ($line, $lineIndent) {
-    if (!trim($line)) return true;
-    if ($this->_getIndent($line) > $lineIndent) return true;
-    return false;
+  function addArrayInline ($array, $indent) {
+    if (empty ($array)) return false;
+    $CommonGroupPath = $this->path;
+
+    foreach ($array as $k => $_) {
+      $this->addArray(array($k => $_), $indent);
+      $this->path = $CommonGroupPath;
+    }
+    return true;
   }
 
-  function addArrayInline ($array, $indent) {
-      $CommonGroupPath = $this->path;
-      if (empty ($array)) return false;
-      
-      foreach ($array as $k => $_) {
-        $this->addArray(array($k => $_), $indent);
-        $this->path = $CommonGroupPath;
-      }
-      return true;
-  }
-  
   function addArray ($array, $indent) {
+
     if (count ($array) > 1)
       return $this->addArrayInline ($array, $indent);
-    
+    if (empty ($array))
+      return false;
 
     $key = key ($array);
-    if (!isset ($array[$key])) return false;
-    if ($array[$key] === array()) { $array[$key] = ''; };
     $value = $array[$key];
 
-    // Unfolding inner array tree as defined in $this->_arrpath.
-    //$_arr = $this->result; $_tree[0] = $_arr; $i = 1;
+    $isMergeKey = $this->isMergeKey($key);
 
     $tempPath = Spyc::flatten ($this->path);
     eval ('$_arr = $this->result' . $tempPath . ';');
 
-
-    if ($this->_containsGroupAlias) {
-      do {
-        if (!isset($this->SavedGroups[$this->_containsGroupAlias])) { echo "Bad group name: $this->_containsGroupAlias."; break; }
-        $groupPath = $this->SavedGroups[$this->_containsGroupAlias];
-        eval ('$value = $this->result' . Spyc::flatten ($groupPath) . ';');
-      } while (false);
-      $this->_containsGroupAlias = false;
+    // Adding string or numeric key to the innermost level or $this->arr.
+    if ($key || is_string($key))
+    {
+      if ($isMergeKey) {
+        if (is_array ($_arr)) { $_arr = array_merge($_arr, $value); } 
+        else { $_arr = $value; }
+      } else {
+        $_arr[$key] = $value;
+      }
     }
-
-
-    // Adding string or numeric key to the innermost level or $this->arr.
-    if ($key)
-    $_arr[$key] = $value;
     else {
       if (!is_array ($_arr)) { $_arr = array ($value); $key = 0; }
       else { $_arr[] = $value; end ($_arr); $key = key ($_arr); }
-
     }
 
-    $this->path[$indent] = $key;
-
+    if (!$isMergeKey) $this->path[$indent] = $key;
     eval ('$this->result' . $tempPath . ' = $_arr;');
 
     if ($this->_containsGroupAnchor) {
@@ -561,7 +591,7 @@
       $this->_containsGroupAnchor = false;
     }
 
-
+    return true;
   }
 
 
@@ -579,41 +609,101 @@
   }
 
 
+  function startsBlockScalar($line) {
+    if (strlen($line) === 0) return false;
+    if ($line{0} !== '|' && $line{0} !== '>') return false;
 
-  function startsLiteralBlock ($line) {
-    $lastChar = substr (trim($line), -1);
-    if (in_array ($lastChar, $this->LiteralBlockMarkers))
-    return $lastChar;
+    $sbinfo = false;
+    if (preg_match ('/^([|>])([0-9]+)?([+-])?$/', $line, $matches)) {
+    // >2+
+      $sbinfo = array();
+      $sbinfo['_']        = $matches[0];
+      $sbinfo['type']     = $matches[1];
+      $sbinfo['indent']   = isset($matches[2]) && $matches[2] !== '' ? $matches[2] : NULL;
+      $sbinfo['chomping'] = isset($matches[3]) && $matches[3] !== '' ? $matches[3] : '';
+    } elseif (preg_match ('/^([|>])([+-])?([0-9]+)?$/', $line, $matches)) {
+    // >+2
+      $sbinfo = array();
+      $sbinfo['_']        = $matches[0];
+      $sbinfo['type']     = $matches[1];
+      $sbinfo['indent']   = isset($matches[3]) && $matches[3] !== '' ? $matches[3] : NULL;
+      $sbinfo['chomping'] = isset($matches[2]) && $matches[2] !== '' ? $matches[2] : '';
+    }
+    return $sbinfo;
+  }
+
+  function blockScalarContinues ($line, $sbinfo) {
+    if (trim($line, " \r\n") === '') return true;
+    if ($this->_getIndent($line) >= $sbinfo['indent']) return true;
     return false;
   }
 
-  function addLiteralLine ($literalBlock, $line, $literalBlockStyle) {
-    $line = $this->stripIndent($line);
-    $line = str_replace ("\r\n", "\n", $line);
+  function returnBlockScalar ($line, $sbinfo) {
+    $line = rtrim ($line, $sbinfo['_'] . "\n");
 
-    if ($literalBlockStyle == '|') {
-      return $literalBlock . $line;
+    // FIXME : 2007-09-15 : lucky
+    // here is look ahead for lines. move it to returnLiteralBlock()
+    if (!isset($sbinfo['indent'])) {
+      // set block indentation from first non empty line
+      $i = $this->line; $c = count($this->Source);
+      while (++$i < $c  && trim($this->Source[$i], " \r\n") === '') {}
+      $sbinfo['indent'] = $i < $c ? $this->_getIndent($this->Source[$i]) : NULL;
     }
-    if (strlen($line) == 0) return $literalBlock . "\n";
+    if ($sbinfo['indent'] > $this->lineIndent) { // it's ok
+      $lines = $this->returnLiteralBlock($line, $sbinfo);
+    } else {
+      // this block contains only empty lines, and i can't to detect indent
+      $this->line = $i - 1;
+      $lines      = array($this->Source[$this->line]);
+    }
 
-   // echo "|$line|";
-    if ($line != "\n")
-      $line = trim ($line, "\r\n ") . " ";
+    $eol = $this->eol;
+    $i = count($lines);
+    // tail comments
+    while (--$i > 0 && $this->isComment(trim($lines[$i]))) { }
+    if ($sbinfo['chomping'] === '-') {
+      $lines = array_slice($lines, 0, $i + 1);
+      if ($i >= 0) $lines[$i] = rtrim($lines[$i], $eol);
+    } elseif ($sbinfo['chomping'] === '') {
+      $lines = array_slice($lines, 0, $i + 1);
+    } /* else $sbinfo['chomping'] == '+' */
 
-    return $literalBlock . $line;
+    // fold
+    if ($sbinfo['type'] === '>') {
+      $i++; // count of lines to fold
+      while (--$i > 0) { 
+        $_line = $lines[$i];
+        if (strlen($_line) === 0 || $_line === $eol) { 
+          $lines[$i] = ''; 
+        } else {
+          $_prevline = $lines[$i - 1];
+          if ($_line{0} !== ' ' && strlen($_prevline) > 0 && $_prevline !== $eol && $_prevline{0} !== ' ') {
+            $lines[$i - 1] = rtrim($_prevline, $eol) . ' ' . $_line;
+            $lines[$i] = '';
+          }
+        }
+      }
+    }
+
+    return $line . implode('', $lines);
   }
 
-  function revertLiteralPlaceHolder ($lineArray, $literalBlock) {
-
-    foreach ($lineArray as $k => $_) {
-      if (substr($_, -1 * strlen ($this->LiteralPlaceHolder)) == $this->LiteralPlaceHolder)
-      $lineArray[$k] = rtrim ($literalBlock, " \r\n");
+  function returnLiteralBlock ($line, $sbinfo) {
+    $lines = array();
+    while (false !== ($textline = $this->nextLine()) && $this->blockScalarContinues($textline, $sbinfo)) {
+      $_line = $this->stripIndent($textline, $sbinfo['indent']);
+      // HACK : 2007-09-15 : lucky
+      // we must take (wrong indented) empty lines too
+      $lines[] = ($_line === false) ? $this->eol : $_line;
     }
-    return $lineArray;
+    if ($textline !== false) $this->line--;
+    return $lines;
   }
 
+
   function stripIndent ($line, $indent = -1) {
     if ($indent == -1) $indent = $this->_getIndent($line);
+    if ($indent === 0) return $line;
     return substr ($line, $indent);
   }
 
@@ -644,9 +734,15 @@
   }
 
 
+  function isMergeKey ($key) {
+    if (preg_match('/^<</', $key)) return true;
+    return false;
+  }
+
   function isComment ($line) {
     if (preg_match('/^#/', $line)) return true;
-    if (trim($line, " \r\n\t") == '---') return true;
+    $s = trim($line, " \r\n\t");
+    if ($s === '' || $s === '---') return true;
     return false;
   }
 
@@ -674,21 +770,11 @@
   }
 
 
-  function startsMappedSequence ($line) {
-    if (preg_match('/^-(.*):$/',$line)) return true;
-  }
-
-  function returnMappedSequence ($line) {
-    $array = array();
-    $key         = trim(substr(substr($line,1),0,-1));
-    $array[$key] = '';
-    return $array;
-  }
-
   function returnMappedValue ($line) {
     $array = array();
     $key         = trim(substr($line,0,-1));
-    $array[$key] = '';
+    $key         = $this->_toTypeKey($key);
+    $array[$key] = $this->emptyValue;
     return $array;
   }
 
@@ -697,7 +783,7 @@
   }
   
   function isPlainArray ($line) {
-    if (preg_match('/^\[(.*)\]$/', $line)) return true;
+    if (preg_match('/^\\[(.*)\\]$/', $line)) return true;
     return false;
   }
   
@@ -712,9 +798,9 @@
     if (preg_match('/^(.+):/',$line,$key)) {
       // It's a key/value pair most likely
       // If the key is in double quotes pull it out
-      if (preg_match('/^(["\'](.*)["\'](\s)*:)/',$line,$matches)) {
-        $value = trim(str_replace($matches[1],'',$line));
-        $key   = $matches[2];
+      if (preg_match('/^((["\']).*\\2)\s*:/',$line,$matches)) {
+        $value = trim(str_replace($matches[0],'',$line));
+        $key   = $matches[1];
       } else {
         // Do some guesswork as to the key and the value
         $explode = explode(':',$line);
@@ -724,12 +810,9 @@
       }
 
       // Set the type of the value.  Int, string, etc
-      $value = $this->_toType($value);
-      if (empty($key)) {
-        $array[]     = $value;
-      } else {
-        $array[$key] = $value;
-      }
+      $key = $this->_toTypeKey($key);
+      $value = $this->_toType($value, true);
+      $array[$key] = $value;
     }
 
     return $array;
@@ -738,28 +821,26 @@
 
 
   function returnArrayElement ($line) {
-     if (strlen($line) <= 1) return array(array()); // Weird %)
-     $array = array();
-     $value   = trim(substr($line,1));
-     $value   = $this->_toType($value);
-     $array[] = $value;
-     return $array;
+    if (strlen($line) <= 1) 
+      return array($this->emptyValue); // Just a speed optimization for empty element
+    $array = array();
+    $value   = trim(substr($line,1));
+    $value   = $this->_toType($value);
+    $array[] = $value;
+    return $array;
   }
 
 
-  function nodeContainsGroup ($line) {
+  function nodeContainsGroupAnchor ($line) {
     $symbolsForReference = 'A-z0-9_\-';
-    if (strpos($line, '&') === false && strpos($line, '*') === false) return false; // Please die fast ;-)
+    if (strpos($line, '&') === false) return false; // Please die fast ;-)
     if (preg_match('/^(&['.$symbolsForReference.']+)/', $line, $matches)) return $matches[1];
-    if (preg_match('/^(\*['.$symbolsForReference.']+)/', $line, $matches)) return $matches[1];
     if (preg_match('/(&['.$symbolsForReference.']+$)/', $line, $matches)) return $matches[1];
-    if (preg_match('/(\*['.$symbolsForReference.']+$)/', $line, $matches)) return $matches[1];
     return false;
   }
 
   function addGroup ($line, $group) {
     if (substr ($group, 0, 1) == '&') $this->_containsGroupAnchor = substr ($group, 1);
-    if (substr ($group, 0, 1) == '*') $this->_containsGroupAlias = substr ($group, 1);
     //print_r ($this->path);
   }
 
Index: test.php
===================================================================
--- test.php	(revision 12)
+++ test.php	(working copy)
@@ -81,11 +81,11 @@
 	die('Sequence 5 failed');
 
 # A folded block as a mapped value
-if ($yaml['no time'] != "There isn't any time for your tricks! \nDo you understand?")
+if ($yaml['no time'] != "There isn't any time for your tricks!\nDo you understand?\n")
 	die("Key: 'no time' failed");
 
 # A literal block as a mapped value
-if ($yaml['some time'] != "There is nothing but time\nfor your tricks.")
+if ($yaml['some time'] != "There is nothing but time\nfor your tricks.\n")
 	die("Key: 'some time' failed");
 
 # Crazy combinations
@@ -153,8 +153,68 @@
 if ($yaml[16] != array( 0 => "a", 1 => array (0 => 1, 1 => 2), 2 => "b"))
 	die("Sequence 16 failed.");
 
+if ($yaml['map with colons'] != array( 
+																			'one'  => "foo bar: bar baz",
+																			'two'  => array(
+																				              'foo bar' => 'bar baz',
+																				              'three'   => 'foo bar: bar baz',
+																			          ),
+	                                    'date' => "20070101 22:59:24", 
+	                                    'four' => "foo - {bar}",
+))
+	print_r($yaml['map with colons']) && die("Sequence 'map with colons' failed.");
 
+if ($yaml['list of maps'] != array(
+	                                 array('name' => 'chris', 'age' => 'young', 'brand' => 'lucky strike'),
+																	 array('compiled languages' => array('C/C++', 'Java'), 
+																				 'all languages list' => array(
+																																			array('C/C++', 'Java'),
+																																			array('Perl', 'Python', 'PHP', 'Ruby'),
+																				 ),
+																				 'all languages map'  => array(
+																																			'compiled'    => array('C/C++', 'Java'),
+																																			'interpreted' => array('Perl', 'Python', 'PHP', 'Ruby'),
+																				 ),
+																	 ),
+))
+	print_r($yaml['list of maps']) && die("Key: 'list of maps' failed");
 
+if ($yaml['more compiled languages'] != array('Haskell', 'C/C++', 'Java'))
+	print_r($yaml['more compiled languages']) && die("Key: 'more compiled languages' failed");
+  
+if ($yaml['full languages list'] != array('Haskell', 'E', 'Perl', 'Python', 'PHP', 'Ruby', 'C/C++', 'Java'))
+	print_r($yaml['full languages list']) && die("Key: 'full languages list' failed");
+
+if ($yaml['stupid map'] != array('i' => 'am', 'another' => 'example', 'of' => 'the', 'key' => 'merging'))
+	print_r($yaml['stupid map']) && die("Key: 'stupid map' failed");
+
+if ($yaml['empty lines'] != array(
+	'PHP Class', 'Basic YAML Loader', 'Very Basic YAML Dumper'
+	))
+	print_r($yaml['empty lines']) && die("Key: 'empty lines' failed");
+
+if ($yaml['empty inlines'] != array(
+																		'list' => array(
+																										array(),
+																										array(),
+																			),
+																		'empty string' =>  '',
+																		'map'  => array(
+																										'list' => array(),
+																										'map' => array(),
+																		),
+	))
+	print_r($yaml['empty inlines']) && die("Key: 'empty inlines' failed");
+
+if ($yaml['quoted keys'] != array(
+																		'' => 'foo',
+																		'bar' => 'string',
+																		'1' => 'one',
+																		2 => 'two',
+	))
+	var_dump($yaml['quoted keys']) || die("Key: 'quoted keys' failed");
+
+
 print "spyc.yaml parsed correctly\n";
 
-?>
\ No newline at end of file
+?>
Index: CHANGES
===================================================================
--- CHANGES	(revision 12)
+++ CHANGES	(working copy)
@@ -25,6 +25,15 @@
     - Some more bugs in the engine are fixed.
     - Only alphanumeric characters are now allowed in reference names.
     - Fixed a bug with inline arrays (thanks Tobiah for pointing it out).
+    - lucky@jetstyle.ru:
+        - Merge keys "<<" are now allowed.
+        - Fixed a bug causing "- arr1: *reference" to not parse correctly.
+        - Fixed a bug 1755793 causing "{}" "[]" to not parse correctly. Now they're empty arrays.
+        - Fixed a bug 1747071 causing ":" "-" not parse correctly in the literal mode.
+        - Fixed a bug 1736736. Empty lines should be considered as comments.
+        - More complete YAML block scalar support (>, |) including chomping and block identation indicators.
+        - Internal support for emptyValue. That can be "-\n" produce "array(Null)" instead of "array('')".
+	- Trim spaces around brackets when parsing inlines "[ foo ]".
     
   0.2.5:
     - All .yml file extensions changed to .yaml (see recommendation: http://yaml.org/faq.html)
Index: spyc.php5
===================================================================
--- spyc.php5	(revision 12)
+++ spyc.php5	(working copy)
@@ -42,9 +42,9 @@
   private $_containsGroupAlias = false;
   private $path;
   private $result;
-  private $LiteralBlockMarkers = array ('>', '|');
-  private $LiteralPlaceHolder = '___YAML_Literal_Block___';
   private $SavedGroups = array();
+  private $emptyValue = ""; /* Just set to NULL for http://yaml.org/type/null.html */
+  private $eol = NULL;      /* End Of Line will be autodetected */
 
   /**#@+
   * @access public
@@ -267,31 +267,28 @@
     $this->path = array();
     $this->result = array();
 
+    // detect End Of line
+    if (!isset($this->eol)) {
+      if    (substr($Source[0], -2, 2) === "\r\n") $this->eol = "\r\n";
+      else  $this->eol = substr($Source[0], -1, 1);
+    }
 
-    for ($i = 0; $i < count($Source); $i++) {
-      $line = $Source[$i];
-      
-      $lineIndent = $this->_getIndent($line);
-      $this->path = $this->getParentPathByIndent($lineIndent);
+    // let's go
+    $this->Source = $Source;
+    $this->line   = -1;
+
+    while (false !== ($line = $this->nextLine())) {
+      $this->lineIndent = $lineIndent = $this->_getIndent($line);
       $line = $this->stripIndent($line, $lineIndent);
+
       if ($this->isComment($line)) continue;
 
-      if ($literalBlockStyle = $this->startsLiteralBlock($line)) {
-        $line = rtrim ($line, $literalBlockStyle . "\n");
-        $literalBlock = '';
-        $line .= $this->LiteralPlaceHolder;
+      $this->path = $this->getParentPathByIndent($lineIndent);
+      $lineArray = $this->_parseLine($line); // can eat more than one line
 
-        while (++$i < count($Source) && $this->literalBlockContinues($Source[$i], $lineIndent)) {
-          $literalBlock = $this->addLiteralLine($literalBlock, $Source[$i], $literalBlockStyle);
-        }
-        $i--;
-      }
-      $lineArray = $this->_parseLine($line);
-      if ($literalBlockStyle)
-      $lineArray = $this->revertLiteralPlaceHolder ($lineArray, $literalBlock);
-
       $this->addArray($lineArray, $lineIndent);
     }
+
     return $this->result;
   }
 
@@ -306,6 +303,11 @@
     return $foo;
   }
 
+  private function nextLine ()
+  {
+    return ($this->line + 1 < count($this->Source)) ? $this->Source[++$this->line]: false;
+  }
+
   /**
      * Finds and returns the indentation of a YAML line
      * @access private
@@ -330,14 +332,11 @@
     if (!$line) return array();
     $array = array();
 
-    if ($group = $this->nodeContainsGroup($line)) {
+    if ($group = $this->nodeContainsGroupAnchor($line)) {
       $this->addGroup($line, $group);
       $line = $this->stripGroup ($line, $group);
     }
 
-    if ($this->startsMappedSequence($line))
-      return $this->returnMappedSequence($line);
-
     if ($this->startsMappedValue($line))
       return $this->returnMappedValue($line);
 
@@ -353,67 +352,111 @@
   }
 
   /**
+     * Finds the type of the passed key, returns the key as the new type.
+     * @access private
+     * @param string $value
+     * @return mixed
+     */
+  private function _toTypeKey($value) {
+
+    if (strpos($value, '#') !== false)
+      $value = trim(preg_replace('/#(.+)$/','',$value));
+
+    if (preg_match('/^("(.*)"|\'(.*)\')$/',$value,$matches)) {
+      $value = (string)preg_replace('/(\'\'|\\\\\')/',"'",end($matches));
+      $value = preg_replace('/\\\\"/','"',$value);
+    } elseif (strtolower($value) == 'null' or $value == '~') {
+      $value = null;
+    } elseif (preg_match ('/^[0-9]+$/', $value)) {
+      $value = (int)$value;
+    } elseif (is_numeric($value)) {
+      $value = (float)$value;
+    } else {
+      // Just a normal string, right?
+
+    }
+
+
+    //  print_r ($value);
+    return $value;
+  }
+
+  /**
      * Finds the type of the passed value, returns the value as the new type.
      * @access private
      * @param string $value
      * @return mixed
      */
-  private function _toType($value) {
+  private function _toType($value, $inline=false) {
 
+    $symbolsForReference = 'A-z0-9_\-';
+
     if (strpos($value, '#') !== false)
       $value = trim(preg_replace('/#(.+)$/','',$value));
 
-    if (preg_match('/^("(.*)"|\'(.*)\')/',$value,$matches)) {
+    if (preg_match('/^("(.*)"|\'(.*)\')$/',$value,$matches)) {
       $value = (string)preg_replace('/(\'\'|\\\\\')/',"'",end($matches));
       $value = preg_replace('/\\\\"/','"',$value);
-    } elseif (preg_match('/^\\[(.+)\\]$/',$value,$matches)) {
+    } elseif (preg_match('/^\\[(.*)\\]$/',$value,$matches)) {
       // Inline Sequence
-
+      $thing = trim($matches[1]);
+      // Propagate value array
+      $value  = array();
       // Take out strings sequences and mappings
-      $explode = $this->_inlineEscape($matches[1]);
+      if ($thing !== '') {
+        $explode = $this->_inlineEscape($thing);
 
-      // Propagate value array
-      $value  = array();
-      foreach ($explode as $v) {
-        $value[] = $this->_toType($v);
+        foreach ($explode as $v) {
+          $value[] = $this->_toType($v);
+        }
       }
-    } elseif (strpos($value,': ')!==false && !preg_match('/^{(.+)/',$value)) {
+    } elseif (preg_match('/^\*(['.$symbolsForReference.']+)/', $value, $matches)) {
+      // It's a alias
+      do {
+        $groupAlias = $matches[1];
+        if (!isset($this->SavedGroups[$groupAlias])) { echo "Bad group name: $groupAlias."; break; }
+        $groupPath = $this->SavedGroups[$groupAlias];
+        eval ('$value = $this->result' . Spyc::flatten ($groupPath) . ';');
+      } while (false);
+    } elseif (!$inline && substr($value, 0, 1) !== '{' && ($_p = strpos($value,': '))!==false) {
       // It's a map
-      $array = explode(': ',$value);
-      $key   = trim($array[0]);
-      array_shift($array);
-      $value = trim(implode(': ',$array));
-      $value = $this->_toType($value);
+      $key   = trim(substr($value, 0, $_p));
+      $key   = $this->_toTypeKey($key);
+      $value = trim(substr($value, $_p+2 )); unset($_p);
+      $value = $this->_toType($value, true);
       $value = array($key => $value);
-    } elseif (preg_match("/{(.+)}$/",$value,$matches)) {
+    } elseif (preg_match("/^{(.*)}$/",$value,$matches)) {
       // Inline Mapping
+      $thing = trim($matches[1]);
+      // Propogate value array
+      $value = array();
+      if ($thing !== '') {
+        // Take out strings sequences and mappings
+        $explode = $this->_inlineEscape($thing);
 
-      // Take out strings sequences and mappings
-      $explode = $this->_inlineEscape($matches[1]);
-
-      // Propogate value array
-      $array = array();
-      foreach ($explode as $v) {
-        $SubArr = $this->_toType($v);
-        if (empty($SubArr)) continue;
-        if (is_array ($SubArr)) {
-          $array[key($SubArr)] = $SubArr[key($SubArr)]; continue;
+        foreach ($explode as $v) {
+          $SubArr = $this->_toType($v);
+          if (empty($SubArr)) continue;
+          if (is_array ($SubArr)) {
+            $value[key($SubArr)] = $SubArr[key($SubArr)]; continue;
+          }
+          $value[] = $SubArr;
         }
-        $array[] = $SubArr;
       }
-      $value = $array;
-    } elseif (strtolower($value) == 'null' or $value == '' or $value == '~') {
+    } elseif (strtolower($value) == 'null' or $value == '~') {
       $value = null;
+    } elseif ($value == '') {
+      $value = $this->emptyValue;
     } elseif (preg_match ('/^[0-9]+$/', $value)) {
       $value = (int)$value;
-    } elseif (in_array(strtolower($value),
-    array('true', 'on', '+', 'yes', 'y'))) {
+    } elseif (in_array(strtolower($value), array('true', 'on', '+', 'yes', 'y'))) {
       $value = true;
-    } elseif (in_array(strtolower($value),
-    array('false', 'off', '-', 'no', 'n'))) {
+    } elseif (in_array(strtolower($value), array('false', 'off', '-', 'no', 'n'))) {
       $value = false;
     } elseif (is_numeric($value)) {
       $value = (float)$value;
+    } elseif ($sbinfo = $this->startsBlockScalar($value)) {
+      $value = $this->returnBlockScalar($value, $sbinfo);
     } else {
       // Just a normal string, right?
 
@@ -446,14 +489,14 @@
     unset($regex);
 
     // Check for sequences
-    if (preg_match_all('/\[(.+)\]/U',$inline,$seqs)) {
-      $inline = preg_replace('/\[(.+)\]/U','YAMLSeq',$inline);
+    if (preg_match_all('/\\[(.*)\\]/U',$inline,$seqs)) {
+      $inline = preg_replace('/\\[(.*)\\]/U','YAMLSeq',$inline);
       $seqs   = $seqs[0];
     }
 
     // Check for mappings
-    if (preg_match_all('/{(.+)}/U',$inline,$maps)) {
-      $inline = preg_replace('/{(.+)}/U','YAMLMap',$inline);
+    if (preg_match_all('/{(.*)}/U',$inline,$maps)) {
+      $inline = preg_replace('/{(.*)}/U','YAMLMap',$inline);
       $maps   = $maps[0];
     }
 
@@ -498,62 +541,48 @@
     return $explode;
   }
 
-  private function literalBlockContinues ($line, $lineIndent) {
-    if (!trim($line)) return true;
-    if ($this->_getIndent($line) > $lineIndent) return true;
-    return false;
+  private function addArrayInline ($array, $indent) {
+    if (empty ($array)) return false;
+    $CommonGroupPath = $this->path;
+
+    foreach ($array as $k => $_) {
+      $this->addArray(array($k => $_), $indent);
+      $this->path = $CommonGroupPath;
+    }
+    return true;
   }
 
-  private function addArrayInline ($array, $indent) {
-      $CommonGroupPath = $this->path;
-      if (empty ($array)) return false;
-      
-      foreach ($array as $k => $_) {
-        $this->addArray(array($k => $_), $indent);
-        $this->path = $CommonGroupPath;
-      }
-      return true;
-  }
-  
   private function addArray ($array, $indent) {
 
     if (count ($array) > 1)
       return $this->addArrayInline ($array, $indent);
-    
+    if (empty ($array))
+      return false;
+
     $key = key ($array);
-    
-    if (!isset ($array[$key])) return false;
-    if ($array[$key] === array()) { $array[$key] = ''; };
     $value = $array[$key];
 
-    // Unfolding inner array tree as defined in $this->_arrpath.
-    //$_arr = $this->result; $_tree[0] = $_arr; $i = 1;
+    $isMergeKey = $this->isMergeKey($key);
 
     $tempPath = Spyc::flatten ($this->path);
     eval ('$_arr = $this->result' . $tempPath . ';');
 
-
-    if ($this->_containsGroupAlias) {
-      do {
-        if (!isset($this->SavedGroups[$this->_containsGroupAlias])) { echo "Bad group name: $this->_containsGroupAlias."; break; }
-        $groupPath = $this->SavedGroups[$this->_containsGroupAlias];
-        eval ('$value = $this->result' . Spyc::flatten ($groupPath) . ';');
-      } while (false);
-      $this->_containsGroupAlias = false;
+    // Adding string or numeric key to the innermost level or $this->arr.
+    if ($key || is_string($key))
+    {
+      if ($isMergeKey) {
+        if (is_array ($_arr)) { $_arr = array_merge($_arr, $value); } 
+        else { $_arr = $value; }
+      } else {
+        $_arr[$key] = $value;
+      }
     }
-
-
-    // Adding string or numeric key to the innermost level or $this->arr.
-    if ($key)
-    $_arr[$key] = $value;
     else {
       if (!is_array ($_arr)) { $_arr = array ($value); $key = 0; }
       else { $_arr[] = $value; end ($_arr); $key = key ($_arr); }
-
     }
 
-    $this->path[$indent] = $key;
-
+    if (!$isMergeKey) $this->path[$indent] = $key;
     eval ('$this->result' . $tempPath . ' = $_arr;');
 
     if ($this->_containsGroupAnchor) {
@@ -561,7 +590,7 @@
       $this->_containsGroupAnchor = false;
     }
 
-
+    return true;
   }
 
 
@@ -579,41 +608,101 @@
   }
 
 
+  private function startsBlockScalar($line) {
+    if (strlen($line) === 0) return false;
+    if ($line{0} !== '|' && $line{0} !== '>') return false;
 
-  private function startsLiteralBlock ($line) {
-    $lastChar = substr (trim($line), -1);
-    if (in_array ($lastChar, $this->LiteralBlockMarkers))
-    return $lastChar;
+    $sbinfo = false;
+    if (preg_match ('/^([|>])([0-9]+)?([+-])?$/', $line, $matches)) {
+    // >2+
+      $sbinfo = array();
+      $sbinfo['_']        = $matches[0];
+      $sbinfo['type']     = $matches[1];
+      $sbinfo['indent']   = isset($matches[2]) && $matches[2] !== '' ? $matches[2] : NULL;
+      $sbinfo['chomping'] = isset($matches[3]) && $matches[3] !== '' ? $matches[3] : '';
+    } elseif (preg_match ('/^([|>])([+-])?([0-9]+)?$/', $line, $matches)) {
+    // >+2
+      $sbinfo = array();
+      $sbinfo['_']        = $matches[0];
+      $sbinfo['type']     = $matches[1];
+      $sbinfo['indent']   = isset($matches[3]) && $matches[3] !== '' ? $matches[3] : NULL;
+      $sbinfo['chomping'] = isset($matches[2]) && $matches[2] !== '' ? $matches[2] : '';
+    }
+    return $sbinfo;
+  }
+
+  private function blockScalarContinues ($line, $sbinfo) {
+    if (trim($line, " \r\n") === '') return true;
+    if ($this->_getIndent($line) >= $sbinfo['indent']) return true;
     return false;
   }
 
-  private function addLiteralLine ($literalBlock, $line, $literalBlockStyle) {
-    $line = $this->stripIndent($line);
-    $line = str_replace ("\r\n", "\n", $line);
+  private function returnBlockScalar ($line, $sbinfo) {
+    $line = rtrim ($line, $sbinfo['_'] . "\n");
 
-    if ($literalBlockStyle == '|') {
-      return $literalBlock . $line;
+    // FIXME : 2007-09-15 : lucky
+    // here is look ahead for lines. move it to returnLiteralBlock()
+    if (!isset($sbinfo['indent'])) {
+      // set block indentation from first non empty line
+      $i = $this->line; $c = count($this->Source);
+      while (++$i < $c  && trim($this->Source[$i], " \r\n") === '') {}
+      $sbinfo['indent'] = $i < $c ? $this->_getIndent($this->Source[$i]) : NULL;
     }
-    if (strlen($line) == 0) return $literalBlock . "\n";
+    if ($sbinfo['indent'] > $this->lineIndent) { // it's ok
+      $lines = $this->returnLiteralBlock($line, $sbinfo);
+    } else {
+      // this block contains only empty lines, and i can't to detect indent
+      $this->line = $i - 1;
+      $lines      = array($this->Source[$this->line]);
+    }
 
-   // echo "|$line|";
-    if ($line != "\n")
-      $line = trim ($line, "\r\n ") . " ";
+    $eol = $this->eol;
+    $i = count($lines);
+    // tail comments
+    while (--$i >= 0 && $this->isComment(trim($lines[$i]))) { }
+    if ($sbinfo['chomping'] === '-') {
+      $lines = array_slice($lines, 0, $i + 1);
+      if ($i >= 0) $lines[$i] = rtrim($lines[$i], $eol);
+    } elseif ($sbinfo['chomping'] === '') {
+      $lines = array_slice($lines, 0, $i + 1);
+    } /* else $sbinfo['chomping'] == '+' */
 
-    return $literalBlock . $line;
+    // fold
+    if ($sbinfo['type'] === '>') {
+      $i++; // count of lines to fold
+      while (--$i > 0) { 
+        $_line = $lines[$i];
+        if (strlen($_line) === 0 || $_line === $eol) { 
+          $lines[$i] = ''; 
+        } else {
+          $_prevline = $lines[$i - 1];
+          if ($_line{0} !== ' ' && strlen($_prevline) > 0 && $_prevline !== $eol && $_prevline{0} !== ' ') {
+            $lines[$i - 1] = rtrim($_prevline, $eol) . ' ' . $_line;
+            $lines[$i] = '';
+          }
+        }
+      }
+    }
+
+    return $line . implode('', $lines);
   }
 
-  private function revertLiteralPlaceHolder ($lineArray, $literalBlock) {
-
-    foreach ($lineArray as $k => $_) {
-      if (substr($_, -1 * strlen ($this->LiteralPlaceHolder)) == $this->LiteralPlaceHolder)
-      $lineArray[$k] = rtrim ($literalBlock, " \r\n");
+  private function returnLiteralBlock ($line, $sbinfo) {
+    $lines = array();
+    while (false !== ($textline = $this->nextLine()) && $this->blockScalarContinues($textline, $sbinfo)) {
+      $_line = $this->stripIndent($textline, $sbinfo['indent']);
+      // HACK : 2007-09-15 : lucky
+      // we must take (wrong indented) empty lines too
+      $lines[] = ($_line === false) ? $this->eol : $_line;
     }
-    return $lineArray;
+    if ($textline !== false) $this->line--;
+    return $lines;
   }
 
+
   private function stripIndent ($line, $indent = -1) {
     if ($indent == -1) $indent = $this->_getIndent($line);
+    if ($indent === 0) return $line;
     return substr ($line, $indent);
   }
 
@@ -644,9 +733,15 @@
   }
 
 
+  private function isMergeKey ($key) {
+    if (preg_match('/^<</', $key)) return true;
+    return false;
+  }
+
   private function isComment ($line) {
     if (preg_match('/^#/', $line)) return true;
-    if (trim($line, " \r\n\t") == '---') return true;
+    $s = trim($line, " \r\n\t");
+    if ($s === '' || $s === '---') return true;
     return false;
   }
 
@@ -674,21 +769,11 @@
   }
 
 
-  private function startsMappedSequence ($line) {
-    if (preg_match('/^-(.*):$/',$line)) return true;
-  }
-
-  private function returnMappedSequence ($line) {
-    $array = array();
-    $key         = trim(substr(substr($line,1),0,-1));
-    $array[$key] = '';
-    return $array;
-  }
-
   private function returnMappedValue ($line) {
     $array = array();
     $key         = trim(substr($line,0,-1));
-    $array[$key] = '';
+    $key         = $this->_toTypeKey($key);
+    $array[$key] = $this->emptyValue;
     return $array;
   }
 
@@ -697,7 +782,7 @@
   }
   
   private function isPlainArray ($line) {
-    if (preg_match('/^\[(.*)\]$/', $line)) return true;
+    if (preg_match('/^\\[(.*)\\]$/', $line)) return true;
     return false;
   }
   
@@ -712,9 +797,9 @@
     if (preg_match('/^(.+):/',$line,$key)) {
       // It's a key/value pair most likely
       // If the key is in double quotes pull it out
-      if (preg_match('/^(["\'](.*)["\'](\s)*:)/',$line,$matches)) {
-        $value = trim(str_replace($matches[1],'',$line));
-        $key   = $matches[2];
+      if (preg_match('/^((["\']).*\\2)\s*:/',$line,$matches)) {
+        $value = trim(str_replace($matches[0],'',$line));
+        $key   = $matches[1];
       } else {
         // Do some guesswork as to the key and the value
         $explode = explode(':',$line);
@@ -724,12 +809,9 @@
       }
 
       // Set the type of the value.  Int, string, etc
-      $value = $this->_toType($value);
-      if (empty($key)) {
-        $array[]     = $value;
-      } else {
-        $array[$key] = $value;
-      }
+      $key = $this->_toTypeKey($key);
+      $value = $this->_toType($value, true);
+      $array[$key] = $value;
     }
 
     return $array;
@@ -738,29 +820,26 @@
 
 
   private function returnArrayElement ($line) {
-     if (strlen($line) <= 1) return array(array()); // Weird %)
-     $array = array();
-     $value   = trim(substr($line,1));
-     $value   = $this->_toType($value);
-     $array[] = $value;
-     return $array;
+    if (strlen($line) <= 1) 
+      return array($this->emptyValue); // Just a speed optimization for empty element
+    $array = array();
+    $value   = trim(substr($line,1));
+    $value   = $this->_toType($value);
+    $array[] = $value;
+    return $array;
   }
 
 
-  private function nodeContainsGroup ($line) {    
+  private function nodeContainsGroupAnchor ($line) {
     $symbolsForReference = 'A-z0-9_\-';
-    if (strpos($line, '&') === false && strpos($line, '*') === false) return false; // Please die fast ;-)
+    if (strpos($line, '&') === false) return false; // Please die fast ;-)
     if (preg_match('/^(&['.$symbolsForReference.']+)/', $line, $matches)) return $matches[1];
-    if (preg_match('/^(\*['.$symbolsForReference.']+)/', $line, $matches)) return $matches[1];
     if (preg_match('/(&['.$symbolsForReference.']+$)/', $line, $matches)) return $matches[1];
-    if (preg_match('/(\*['.$symbolsForReference.']+$)/', $line, $matches)) return $matches[1];
     return false;
-
   }
 
   private function addGroup ($line, $group) {
     if (substr ($group, 0, 1) == '&') $this->_containsGroupAnchor = substr ($group, 1);
-    if (substr ($group, 0, 1) == '*') $this->_containsGroupAlias = substr ($group, 1);
     //print_r ($this->path);
   }
 
Index: test.php5
===================================================================
--- test.php5	(revision 12)
+++ test.php5	(working copy)
@@ -81,11 +81,11 @@
 	die('Sequence 5 failed');
 
 # A folded block as a mapped value
-if ($yaml['no time'] != "There isn't any time for your tricks! \nDo you understand?")
+if ($yaml['no time'] != "There isn't any time for your tricks!\nDo you understand?\n")
 	die("Key: 'no time' failed");
 
 # A literal block as a mapped value
-if ($yaml['some time'] != "There is nothing but time\nfor your tricks.")
+if ($yaml['some time'] != "There is nothing but time\nfor your tricks.\n")
 	die("Key: 'some time' failed");
 
 # Crazy combinations
@@ -153,8 +153,86 @@
 if ($yaml[16] != array( 0 => "a", 1 => array (0 => 1, 1 => 2), 2 => "b"))
 	die("Sequence 16 failed.");
 
+if ($yaml['map with colons'] != array( 
+																			'one'  => "foo bar: bar baz",
+																			'two'  => array(
+																				              'foo bar' => 'bar baz',
+																				              'three'   => 'foo bar: bar baz',
+																			          ),
+	                                    'date' => "20070101 22:59:24", 
+	                                    'four' => "foo - {bar}", 
+))
+	print_r($yaml['map with colons']) && die("Sequence 'map with colons' failed.");
 
+if ($yaml['list of maps'] != array(
+	                                 array('name' => 'chris', 'age' => 'young', 'brand' => 'lucky strike'),
+																	 array('compiled languages' => array('C/C++', 'Java'), 
+																				 'all languages list' => array(
+																																			array('C/C++', 'Java'),
+																																			array('Perl', 'Python', 'PHP', 'Ruby'),
+																				 ),
+																				 'all languages map'  => array(
+																																			'compiled'    => array('C/C++', 'Java'),
+																																			'interpreted' => array('Perl', 'Python', 'PHP', 'Ruby'),
+																				 ),
+																	 ),
+))
+	print_r($yaml['list of maps']) && die("Key: 'list of maps' failed");
 
+if ($yaml['more compiled languages'] != array('Haskell', 'C/C++', 'Java'))
+	print_r($yaml['more compiled languages']) && die("Key: 'more compiled languages' failed");
+  
+if ($yaml['full languages list'] != array('Haskell', 'E', 'Perl', 'Python', 'PHP', 'Ruby', 'C/C++', 'Java'))
+	print_r($yaml['full languages list']) && die("Key: 'full languages list' failed");
+
+if ($yaml['stupid map'] != array('i' => 'am', 'another' => 'example', 'of' => 'the', 'key' => 'merging'))
+	print_r($yaml['stupid map']) && die("Key: 'stupid map' failed");
+
+if ($yaml['empty lines'] != array(
+	'PHP Class', 'Basic YAML Loader', 'Very Basic YAML Dumper'
+	))
+	print_r($yaml['empty lines']) && die("Key: 'empty lines' failed");
+
+if ($yaml['empty inlines'] != array(
+																		'list' => array(
+																										array(),
+																										array(),
+																			),
+																		'empty string' =>  '',
+																		'map'  => array(
+																										'list' => array(),
+																										'map' => array(),
+																		),
+	))
+	print_r($yaml['empty inlines']) && die("Key: 'empty inlines' failed");
+
+if ($yaml['strip'] != "text")
+	var_dump($yaml['strip']) && die("Key: 'strip' failed");
+
+if ($yaml['clip'] != "text\n")
+	var_dump($yaml['clip']) && die("Key: 'clip' failed");
+ 
+if ($yaml['keep'] != "text\n")
+	var_dump($yaml['keep']) || die("Key: 'keep' failed");
+
+if ($yaml['strip empty'] != "")
+	var_dump($yaml['strip empty']) || die("Key: 'strip empty' failed");
+
+if ($yaml['clip empty'] != "")
+	var_dump($yaml['clip empty']) || die("Key: 'clip empty' failed");
+ 
+if ($yaml['keep empty'] != "\n")
+	var_dump($yaml['keep empty']) || die("Key: 'keep empty' failed");
+
+if ($yaml['quoted keys'] != array(
+																		'' => 'foo',
+																		'bar' => 'string',
+																		'1' => 'one',
+																		2 => 'two',
+	))
+	var_dump($yaml['quoted keys']) || die("Key: 'quoted keys' failed");
+
+
 print "spyc.yaml parsed correctly\n";
 
 ?>
